=== PAMIĘĆ DZIELONA (1 segment) ===
SharedState [ftok /tmp,'S'] — wspólny stan symulacji, dostęp chroniony SEM_SHM_MUTEX
  - start_time_sec/nsec    — timestamp startu (do logów)
  - shutdown               — flaga zakończenia (dyrektor ustawia, wszyscy czytają)
  - director_pid           — PID dyrektora
  - registration_pid       — PID rejestracji
  - doctor_pids[7]         — PID-y lekarzy (do wysyłania SIGUSR1/SIGUSR2)
  - doctor_on_break[7]     — flagi: czy lekarz jest na oddziale po SIGUSR1
  - reg_window_2_open      — czy okienko 2 jest otwarte
  - reg_queue_count        — ile osób w kolejce do rejestracji (decyduje o okienku 2)
  - total_patients         — ile pacjentów wygenerowano łącznie
  - patients_in_sor        — ile osób aktualnie w budynku (dziecko+opiekun=2)
  - active_patient_count   — ile procesów pacjentów żyje (do limitu -p)
  - max_patients           — limit procesów (parametr -p, 0=brak)
  - specialist_msgids[7]   — ID kolejek specjalistów ([0]=−1, [1..6]=kolejki)
  - log_file[256]          — ścieżka do pliku logu

=== SEMAFORY (13 w jednym zestawie) [ftok /tmp,'E'] ===
 [0] SEM_POCZEKALNIA          — counting(N=5), wolne miejsca w poczekalni; -1 dorosły, -2 dziecko+opiekun
 [1] SEM_REG_QUEUE_MUTEX      — mutex, chroni reg_queue_count w SharedState
 [2] SEM_REG_WINDOW_1         — binary(1), stan okienka 1 (zawsze otwarte)
 [3] SEM_REG_WINDOW_2         — binary(0), stan okienka 2 (dynamiczne otwarcie/zamknięcie)
 [4] SEM_SPECIALIST_KARDIOLOG — binary(1), 1 pacjent na raz u kardiologa
 [5] SEM_SPECIALIST_NEUROLOG  — binary(1), 1 pacjent na raz u neurologa
 [6] SEM_SPECIALIST_OKULISTA  — binary(1), 1 pacjent na raz u okulisty
 [7] SEM_SPECIALIST_LARYNGOLOG— binary(1), 1 pacjent na raz u laryngologa
 [8] SEM_SPECIALIST_CHIRURG   — binary(1), 1 pacjent na raz u chirurga
 [9] SEM_SPECIALIST_PEDIATRA  — binary(1), 1 pacjent na raz u pediatry
[10] SEM_SHM_MUTEX            — mutex, chroni cały SharedState przed race condition
[11] SEM_LOG_MUTEX            — mutex, chroni zapis do pliku logu (1 proces pisze naraz)
[12] SEM_REG_QUEUE_CHANGED    — event(0), budzi kontroler okienka 2 gdy kolejka się zmieni

=== KOLEJKI KOMUNIKATÓW (7 kolejek) ===

GŁÓWNA [ftok /tmp,'M'] — centralna komunikacja pacjent↔rejestracja↔POZ↔specjalista
  mtype=1           — pacjent VIP → rejestracja (priorytet przez msgrcv -2)
  mtype=2           — pacjent zwykły → rejestracja
  mtype=3           — pacjent → lekarz POZ (triaż, FIFO)
  mtype=10000+id      — rejestracja → pacjent X (potwierdzenie rejestracji)
  mtype=20000+id      — POZ → pacjent X (kolor triażu + przypisany specjalista)
  mtype=30000+id      — specjalista → pacjent X (wynik: dom/oddział/inna placówka)

KARDIOLOG  [ftok /tmp,'a'] — pacjenci czekający na kardiologa, mtype=kolor (1=RED,2=YELLOW,3=GREEN)
NEUROLOG   [ftok /tmp,'b'] — j.w. dla neurologa
OKULISTA   [ftok /tmp,'c'] — j.w. dla okulisty
LARYNGOLOG [ftok /tmp,'d'] — j.w. dla laryngologa
CHIRURG    [ftok /tmp,'e'] — j.w. dla chirurga
PEDIATRA   [ftok /tmp,'f'] — j.w. dla pediatry (dzieci <18 trafiają TYLKO tutaj)
  → Lekarz odbiera msgrcv(-3) = najniższy mtype pierwszy = RED przed YELLOW przed GREEN


=== CO SIĘ DZIEJE PO URUCHOMIENIU ./dyrektor — KROK PO KROKU ===

--- FAZA 1: INICJALIZACJA (main.cpp → main()) ---

1.  Dyrektor parsuje argumenty linii komend (-t sekundy, -p maks_procesów).
    Walidacja: -t musi być >0, -p musi być > FIXED_PROCESS_COUNT (10).
    Jeśli dane nieprawidłowe → wypisz komunikat błędu + exit.

2.  Ustaw handlery sygnałów (sigaction): SIGINT, SIGTERM, SIGHUP → ustawiają
    g_shutdown=1 i state->shutdown=1. Rejestruj atexit(cleanupIPC).

3.  initIPC() — tworzenie wszystkich zasobów IPC:

    3a. PAMIĘĆ DZIELONA: ftok(/tmp,'S') → shmget(IPC_CREAT|IPC_EXCL|0600)
        → shmat() → memset(0). Segment ma rozmiar sizeof(SharedState).
        Jeśli stary segment istnieje — najpierw shmctl(IPC_RMID).

    3b. SEMAFORY: ftok(/tmp,'E') → semget(SEM_COUNT=13, IPC_CREAT|IPC_EXCL|0600)
        → semctl(SETALL) z wartościami początkowymi:
          [0] SEM_POCZEKALNIA = N (20 wolnych miejsc)
          [1] SEM_REG_QUEUE_MUTEX = 1
          [4-9] SEM_SPECIALIST_* = 1 (każdy specjalista wolny)
          [10] SEM_SHM_MUTEX = 1
          [11] SEM_LOG_MUTEX = 1
          [12] SEM_REG_QUEUE_CHANGED = 0 (kontroler czeka)

    3c. GŁÓWNA KOLEJKA KOMUNIKATÓW: ftok(/tmp,'M') → msgget(IPC_CREAT|IPC_EXCL|0600)

    3d. 6 KOLEJEK SPECJALISTÓW: ftok(/tmp,'a'..'f') → msgget(IPC_CREAT|IPC_EXCL|0600)
        ID każdej kolejki zapisany w state->specialist_msgids[1..6].
        specialist_msgids[0] (POZ) = -1 (nie używa dedykowanej kolejki).

4.  Zapisz w SharedState: start_time (CLOCK_MONOTONIC), director_pid, shutdown=0,
    max_patients, ścieżkę pliku logu ("sor_log.txt"). Wyczyść plik logu (fopen "w").

--- FAZA 2: URUCHOMIENIE PROCESÓW POTOMNYCH ---

5.  startRegistration(): fork() → prctl(PR_SET_PDEATHSIG, SIGTERM)
    → execl("./rejestracja"). PID zapisany w state->registration_pid i g_child_pids[].

6.  startDoctors(): pętla i=0..6 (DOCTOR_COUNT=7), dla każdego lekarza:
    fork() → prctl(PR_SET_PDEATHSIG, SIGTERM) → execl("./lekarz", typ_str).
    Typ lekarza przekazany jako argument: 0=POZ, 1=kardiolog, ..., 6=pediatra.
    PIDy zapisane w state->doctor_pids[i] i g_child_pids[].

7.  setRawTerminal(): tcgetattr() zapamiętuje oryginalne ustawienia terminala,
    wyłącza ICANON i ECHO (tryb raw). Klawisze reagują natychmiast bez Enter.

8.  Fork + execl("./generator") — uruchomienie generatora pacjentów.
    PID zapisany w g_generator_pid i g_child_pids[].

--- FAZA 3: CO ROBI KAŻDY PROCES PO STARCIE ---

  === REJESTRACJA (rejestracja.cpp) ===

9.  Podłącza się do istniejących IPC: shmget(0) → shmat(), semget(0), msgget(0).

10. Tworzy 2 dodatkowe wątki (pthread_create):
    - wątek kontrolera kolejki (queueControllerThread)
    - wątek okienka 2 (windowThread) — startuje nieaktywny, czeka na pthread_cond_wait

11. Wątek główny = okienko 1. Pętla:
    → msgrcv(główna kolejka, mtype=-2, blokująco)
      Ujemny mtype=-2 oznacza: odbierz wiadomość z mtype ≤ 2, najniższy pierwszy.
      VIP (mtype=1) ma priorytet przed zwykłym (mtype=2).
    → processPatient(): dekrementuj reg_queue_count, semSignal(SEM_REG_QUEUE_CHANGED),
      randomSleep(250-500ms), msgsnd odpowiedź (mtype=10000+id) do pacjenta.

12. Kontroler kolejki (queueControllerThread): pętla:
    → semWait(SEM_REG_QUEUE_CHANGED) — blokuje do sygnału zmiany kolejki.
    → Odczytaj reg_queue_count z SharedState (pod SEM_SHM_MUTEX).
    → Jeśli queue >= K_OPEN (10) i okienko 2 zamknięte → otwórz:
      ustaw reg_window_2_open=1, pthread_cond_signal obudzi wątek okienka 2.
    → Jeśli queue < K_CLOSE (7) i okienko 2 otwarte → zamknij:
      ustaw reg_window_2_open=0, g_window2_should_run=false,
      pthread_kill(SIGUSR1) do wątku okienka 2 (przerywa jego msgrcv z EINTR).

13. Wątek okienka 2: pętla czekania na aktywację → pthread_cond_wait.
    Po obudzeniu: ta sama logika co okienko 1 (msgrcv z priorytetem VIP).
    Gdy g_window2_should_run staje się false → wątek wraca do czekania.

  === LEKARZE (lekarz.cpp) ===

14. Każdy lekarz: podłącz IPC (shmget, semget, msgget). Ustaw sigaction:
    SIGUSR1 → g_go_to_ward=1, SIGUSR2 → g_shutdown=1, SIGTERM → g_shutdown=1.
    Bez SA_RESTART — blokujące wywołania (msgrcv, semop) przerywane przez sygnały.

15. Lekarz POZ (typ=0) — runPOZ(): pętla:
    → msgrcv(główna kolejka, mtype=MSG_PATIENT_TO_TRIAGE=3, blokująco)
    → randomSleep(1000-2000ms) — symulacja triażu
    → randomTriageColor(): 10% czerwony, 35% żółty, 50% zielony, 5% odesłany
    → Jeśli odesłany: msgsnd odpowiedź (mtype=20000+id, assigned_doctor=POZ)
    → Jeśli nie: randomSpecialist(wiek) → dzieci <18 → pediatra, dorośli → losowy
      z {kardiolog, neurolog, okulista, laryngolog, chirurg}.
      msgsnd odpowiedź (mtype=20000+id, kolor + specjalista)
    → POZ NIE reaguje na SIGUSR1 (nie chodzi na oddział).

16. Lekarze specjaliści (typ=1..6) — runSpecialist(): pętla:
    → msgrcv(dedykowana kolejka specjalisty, mtype=-3, blokująco)
      Ujemny mtype=-3 → najniższy mtype pierwszy: RED(1) > YELLOW(2) > GREEN(3).
    → semWait(SEM_SPECIALIST_X) — zajmij gabinet (1 pacjent naraz)
    → g_treating=1, randomSleep(2000-3000ms) — symulacja badania
    → randomOutcome(): 85% do domu, 14.5% oddział, 0.5% inna placówka
    → msgsnd odpowiedź (mtype=30000+id) na główną kolejkę
    → g_treating=0, semSignal(SEM_SPECIALIST_X) — zwolnij gabinet
    → Jeśli g_go_to_ward=1: goToWard() → ustaw doctor_on_break[X]=1,
      randomSleep(250-500ms), doctor_on_break[X]=0, g_go_to_ward=0.

  === GENERATOR (generator.cpp) ===

17. Podłącza się do IPC. Ustaw sigaction: SIGTERM/SIGINT → g_gen_shutdown=1.

18. Pętla generowania pacjentów:
    → randomSleep(500-1000ms)
    → Jeśli jest limit (-p): sprawdź active_patient_count < (max_patients - 10).
      Jeśli pełno → polluj co 100ms.
    → Losuj: wiek (20% dzieci 1-17, 80% dorośli 18-90), VIP (10% szans)
    → Inkrementuj active_patient_count w SharedState (pod SEM_SHM_MUTEX)
    → fork() → prctl(PR_SET_PDEATHSIG, SIGTERM) → execl("./pacjent", id, wiek, vip)
    → Zapisz PID w tablicy g_patient_pids[]
    → waitpid(-1, WNOHANG) — zbierz zakończone procesy (anty-zombie)

  === PACJENT (pacjent.cpp) ===

19. Parsuj argumenty (id, wiek, vip). Podłącz IPC. Ustaw sigaction:
    SIGUSR2/SIGTERM/SIGINT → g_shutdown=1.

20. DOROSŁY (wiek ≥ 18) — sekwencyjnie w jednym wątku:

    20a. enterWaitingRoom(): semWait(SEM_POCZEKALNIA) — blokuje jeśli 0 wolnych miejsc.
         Inkrementuj patients_in_sor (pod SEM_SHM_MUTEX).

    20b. doRegistration():
         → Inkrementuj reg_queue_count (pod SEM_SHM_MUTEX)
         → semSignal(SEM_REG_QUEUE_CHANGED) — obudź kontroler okienka 2
         → msgsnd na główną kolejkę (mtype=1 dla VIP, mtype=2 dla zwykłego)
         → Blokujący msgrcv czekający na mtype=10000+id (odpowiedź rejestracji)

    20c. doTriage():
         → msgsnd na główną kolejkę (mtype=3=MSG_PATIENT_TO_TRIAGE)
         → Blokujący msgrcv czekający na mtype=20000+id (odpowiedź POZ)
         → Zapisz kolor i assigned_doctor. Jeśli COLOR_SENT_HOME → sent_home=true.

    20d. doSpecialist() (jeśli nie odesłany):
         → msgsnd na dedykowaną kolejkę specjalisty (mtype = kolor: 1/2/3)
         → Blokujący msgrcv czekający na mtype=30000+id (odpowiedź specjalisty)

    20e. exitSOR():
         → Dekrementuj patients_in_sor i active_patient_count (pod SEM_SHM_MUTEX)
         → semSignal(SEM_POCZEKALNIA) — zwolnij 1 miejsce, obudź czekającego pacjenta

21. DZIECKO (wiek < 18) — jeden proces, DWA wątki (pthread_create):

    21a. Wątek Rodzica (parentThread):
         → enterWaitingRoom(): semop(-2, SEM_POCZEKALNIA) — zajmij 2 miejsca atomowo
         → doRegistration() — tak samo jak dorosły
         → pthread_mutex_lock → registration_complete=true → pthread_cond_signal
           (obudź wątek dziecka)

    21b. Wątek Dziecka (childThread):
         → pthread_cond_wait — czeka aż rodzic skończy rejestrację
         → doTriage() — triaż u POZ
         → doSpecialist() — leczenie (jeśli nie odesłane)

    21c. main() czeka: pthread_join(rodzic), pthread_join(dziecko)
         → exitSOR(): semop(+2, SEM_POCZEKALNIA) — zwolnij 2 miejsca atomowo

--- FAZA 4: PĘTLA GŁÓWNA DYREKTORA ---

22. handleKeyboard(): pętla select() z timeoutem 100ms na STDIN:
    → Klawisz '1'-'6': kill(doctor_pids[X], SIGUSR1) — wyślij lekarza na oddział
    → Klawisz '7': ewakuacja — state->shutdown=1, kill(SIGUSR2) do wszystkich
    → Klawisz 'q': state->shutdown=1, g_shutdown=1 — czyste zamknięcie
    → Sprawdź timeout (-t): jeśli getElapsedTime >= max_time → shutdown
    → Sprawdź state->shutdown (mógł ustawić inny proces)

--- FAZA 5: ZAMYKANIE SYMULACJI ---

23. restoreTerminal(): tcsetattr() przywraca oryginalne ustawienia terminala.

24. state->shutdown = 1 (jeśli jeszcze nie ustawione).

25. Zamknij generator PIERWSZY (bo on jest rodzicem pacjentów):
    → kill(generator_pid, SIGTERM)
    → Polluj waitpid(WNOHANG) do 5s
    → Generator po SIGTERM: wysyła SIGTERM do swoich pacjentów,
      waitpid zbiera dzieci (do 3s), potem SIGKILL na pozostałe, shmdt.
    → Jeśli generator nie zakończył się w 5s → SIGKILL + waitpid(blokujący)

26. Zamknij pozostałe procesy (lekarze + rejestracja):
    → kill(SIGTERM) do każdego
    → usleep(500ms) — czas na graceful shutdown
    → kill(SIGKILL) + waitpid(blokujący) na każdego — safety net

27. cleanupIPC(): 
    → shmdt(state) — odłącz pamięć dzieloną
    → shmctl(IPC_RMID) — usuń segment pamięci dzielonej
    → semctl(IPC_RMID) — usuń zestaw 13 semaforów
    → msgctl(IPC_RMID) — usuń główną kolejkę komunikatów
    → msgctl(IPC_RMID) × 6 — usuń kolejki specjalistów

28. Po zakończeniu: ipcs powinno być czyste, ps nie powinno pokazywać żadnych
    procesów symulacji (dyrektor, lekarz, pacjent, rejestracja, generator).

--- FAZA AWARYJNA: jeśli dyrektor zginie (kill -9) ---

29. prctl(PR_SET_PDEATHSIG, SIGTERM) — kernel automatycznie wysyła SIGTERM
    do generatora, rejestracji i lekarzy gdy dyrektor umrze.

30. Rejestracja (przy zamykaniu): sprawdza kill(director_pid, 0).
    Jeśli dyrektor martwy → sama sprząta IPC (shm, sem, msg) jako safety net.
