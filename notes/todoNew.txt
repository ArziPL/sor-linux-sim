


ZAŁOŻENIA

C++ / Cmake / Debian

Uwagi ogólne 1. Zasady wyboru tematu projektu 1.1. Tematy można wybrać z puli przykładowych tematów zawartych w tym dokumencie. 1.2. Możliwe jest zgłoszenie własnego tematu. Należy przesłać prowadzącemu propozycje opisu i testów (w formie opisanej w dalszej części dokumentu). Własne tematy muszą być zgłoszone i zaakceptowane w jednoznaczny sposób przez prowadzącego najpóźniej do 30 listopada 2025. W szczególności stwierdzenie: “temat jest w porządku, ale należy zmienić X” nie jest zaakceptowaniem tematu. 1.3. Opisy projektów i testów mogą ulec niewielkim modyfikacjom mającym na celu usunięcie niejasności lub dodanie autorskich rozwiązań. 1.4. W danej grupie laboratoryjnej możliwa jest realizacja danego tematu niezależnie przez maksymalnie jedną osobę – lista grup jest dostępna na kanale Projekty w zespole SYSTEMY OPERACYJNE ewentualnie o skompletowanie listy zbiorczej tematów dla danej grupy i przesłanie jej za pomocą wiadomości w systemie Moodle proszeni są starostowie danej grupy lub osoby wybrane przez daną grupę. W przypadku braku takiej listy decyzję o przyznaniu lub nie danego tematu (z puli dostępnych poniżej) danej osobie podejmie prowadzący do dnia 1 grudnia 2025. 2. Zasady opisu i zgłoszenia danego zadania 2.1. Opis zadań i testów powinien być analogiczny do zamieszczonych w poniższym dokumencie 2.2. Wybrany temat (zarówno ten z dostępnej poniżej puli jak i indywidualny) musi być opisany w pliku typu Markdown z rozszerzeniem „.md”. 2.3. Nazwa pliku z opisem powinna mieć format: „NAZWISKO_IMIĘ_NR ALBUMU_opis_XXX.md”, gdzie XXX oznacza „temat_wybranego_projektu” (np.: KOWALSKA_ANNA_123456_opis_REJS.md). 2.4. Tematy projektów wraz z ich opisem oraz opisem testów należy przesłać w systemie Moodle w zadaniu pt. „Wybór tematu projektu” 2.5. Dla każdego projektu należy stworzyć jego repozytorium (publiczne) w systemie GitHub oraz zamieścić link do niego w przesyłanym opisie. 3. Zasady oddawania projektów 3.1. Ostateczny termin oddania projektu (odesłania na deltę po prezentacji) to 21 stycznia 2026r. Za każdy dzień zwłoki odejmowany jest 1% z oceny końcowej. 3.2. Raport z projektu spakowany wraz ze źródłami (skopiowanymi z GitHub-a) należy przesłać w systemie Moodle (delta.pk.edu.pl) w zadaniu pt. „Projekt” do 21 stycznia 2026r. 3.3. Przed odesłaniem na deltę obowiązkowa prezentacja u prowadzącego zajęcia projektowe. 4. Wymagania w stosunku do projektów oraz raportu 4.1. Wymagania obowiązkowe: a. Konieczne jest udokumentowanie wymaganych przypadków użycia mieszczących się w ramach opisu zadania. b. Wszystkie dane wprowadzane przez użytkownika powinny być sprawdzane (np: maksymalna dopuszczalna dla danego użytkownika liczba procesów do uruchomienia), w razie wpisania niepoprawnych wartości powinna zostać wyświetlona wiadomość informująca użytkownika. c. Dla wszystkich funkcji systemowych zaimplementuj obsługę błędów używając funkcji bibliotecznej perror() i zmiennej errno. 3 d. Do tworzonych struktur (np.: pamięć dzielona, semafory, kolejki komunikatów, …, itp.) ustawić minimalne prawa dostępu, konieczne do wykonania zadania. e. Po zakończeniu zadania wszystkie używane struktury muszą być usunięte chyba, że w zadaniu wyraźnie określono która z nich ma pozostać (np.: segment pamięci dzielonej). f. Program napisany w C/C++. g. Należy unikać rozwiązań scentralizowanych – symulacja działa na procesach - obowiązkowe użycie funkcji fork() i exec(). 5. Zawartość raportu oraz sposób oceny projektu 5.1. Raport ma być treściwy i w miarę krótki. Ma zawierać założenia projektowe kodu, ogólny opis kodu, co udało się zrobić, z czym były problemy, dodane elementy specjalne, zauważone problemy z testami. 5.2. Na końcu raportu muszą się znaleźć opisane linki do istotnych fragmentów kodu (w źródłach na GitHub) który obrazuje wymagane w projekcie użyte konstrukcje (funkcje systemowe) takie jak: a. Tworzenie i obsługa plików (creat(), open(), close(), read(), write(), unlink()); b. Tworzenie procesów (fork(), ecec(), exit(), wait()); c. Tworzenie i obsługa wątków (pthread_create(), pthread_join(), pthread_detach(), pthread_exit(), pthread_mutex_lock(), pthread_mutex_unlock(), pthread_mutex_trylock(), pthread_cond_wait(), pthread_cond_signal(), pthread_cond_broadcast()); d. Obsługa sygnałów (kill(), raise(), signal(), sigaction()); e. Synchronizacja procesów(wątków) (ftok(), semget(), semctl(), semop()); f. Łącza nazwane i nienazwane (mkfifo(), pipe(), dup(), dup2(), popen()); g. Segmenty pamięci dzielonej (ftok(), shmget(), shmat(), shmdt(), shmctl()); h. Kolejki komunikatów (ftok(), msgget(), msgsnd(), msgrcv(), msgctl()); i. Gniazda (socket(), bind(), listen(), accept(), connect(), • Linki mogą zostać stworzone np. tak jak opisano to w: https://help.github.com/en/github/managing-your-work-ongithub/creating-apermanent-link-to-a-code-snippet • Idea linków do kodu zakłada, że osoba oceniająca projekt szybko się po ich zawartości zorientuje jak zgodny z założeniami jest projekt i ułatwi jego ocenę. 5.3. Punktacja: a. 10% - zgodność programu z opisem w temacie zadania • Wygląd/interfejs/ programu może być inny niż w opisie, pod warunkiem, że wszystkie podstawowe funkcjonalności pozostaną zgodne z opisem; • Dodatkowe funkcjonalności można dodawać wedle uznania, pamiętając jednak, że im większy program tym więcej miejsc w których można popełnić błąd. b. 20% - poprawność funkcjonalna • Seria testów zależna od tematu. Każdy zaliczony test daje 1/N*20% punktów, gdzie N to liczba testów przewidzianych dla danego tematu. Celem testów jest sprawdzenie czy w określonych warunkach nie dochodzi do: blokady, zakleszczenia, 4 przekroczenia maksymalnej liczby procesów, …, itp. Testy opisane szczegółowo w raporcie. Minimalna liczba testów 4. c. 20% - poprawne wykorzystanie czterech wybranych z poniższej listy konstrukcji (każda za 5%): • Tworzenie i obsługa procesów lub/i wątków; • Zastosowanie systemowych mechanizmów synchronizacji procesów i/lub wątków – programowanie współbieżne dla procesów/wątków działających asynchronicznie. • Zastosowane co najmniej dwóch różnych mechanizmów komunikacji między procesami (np. kolejka komunikatów do synchronizacji, pamięć dzielona do wymiany danych); • Obsługa sygnałów (co najmniej dla dwóch różnych sygnałów); • Wyjątki/obsługa błędów (m.in. walidacja danych wprowadzanych przez użytkownika) - zdefiniowanie własnej funkcji do zgłoszenia i obsługi wyjątków. • Własne moduły (podział programu na przynajmniej dwa pliki, np. jeden do obsługi logiki, kolejne do obsługi napisanych procedur). d. 10% - wyróżniające elementy, w szczególności: • Wykorzystanie zaawansowanych konstrukcji programistycznych (ponad opisane/wymienione w pkt. 5.2). • Wykorzystanie zaawansowanych algorytmów zapewniających dodatkową funkcjonalność ponad opisane minimum. • Interfejs graficzny (lub synchronizacja i kolorowanie wyjścia terminala) obrazujący działanie symulacji. e. 40% - Czytelność i udokumentowanie kodu (opis procedur, pseudokody kluczowych algorytmów, komentarze) oraz aktywność na GitHub (ilość i systematyka dokonywania komitów – ogólnie pojęte „development activity”). Tematy i opisy projektów Uwagi ogólne do wszystkich tematów: • należy unikać rozwiązań scentralizowanych – realizacja symulacji na procesach; • program napisany w C/C++;



# Temat 8 – SOR (doprecyzowana interpretacja implementacyjna)

SOR działa przez całą dobę, zapewniając natychmiastową pomoc osobom w stanach nagłego zagrożenia zdrowia i życia. Działanie SOR-u opiera się na triażu, czyli ocenie stanu pacjentów, która określa priorytet udzielania pomocy (nie decyduje kolejność zgłoszenia). W SOR znajduje się **poczekalnia o pojemności N**.

---

## Zasady działania SOR

* SOR jest czynny całą dobę.
* W poczekalni SOR w danej chwili może się znajdować **co najwyżej N pacjentów** (pozostali pacjenci oczekują przed wejściem na zwolnienie miejsca).
* **Poczekalnia jest wspólnym miejscem przebywania pacjentów w SOR** i stanowi ograniczenie pojemności:

  * pacjent zajmuje miejsce w poczekalni **od momentu wejścia do SOR aż do momentu opuszczenia SOR**,
  * pacjent **zajmuje miejsce również wtedy, gdy jest w trakcie triażu lub u lekarza specjalisty**,
  * **nowy pacjent może wejść do SOR dopiero wtedy, gdy inny pacjent opuści SOR i zwolni miejsce w poczekalni**.
* Kolejność obsługi pacjentów nie jest globalnym FIFO — **każdy etap ma własną kolejkę i własne reguły**:

  * rejestracja ma reguły kolejkowania rejestracji (w tym VIP),
  * triaż i dalsza obsługa ma reguły priorytetu medycznego (kolory).
* Dzieci w wieku poniżej 18 lat na SOR przychodzą pod opieką osoby dorosłej.
* Każdy pacjent przed wizytą u lekarza musi się udać do rejestracji.
* W SOR znajdują się **2 okienka rejestracji**, przy czym:

  * zawsze działa co najmniej jedno stanowisko,
  * jeżeli w kolejce do rejestracji znajduje się więcej niż **K pacjentów (K ≥ N/2)**, otwierane jest drugie okienko,
  * drugie okienko zostaje zamknięte, jeżeli liczba pacjentów w kolejce do rejestracji spadnie poniżej **N/3**.

---

## Rejestracja i VIP

* Na etapie rejestracji funkcjonują **dwie oddzielne kolejki**:

  * kolejka rejestracji dla pacjentów zwykłych,
  * kolejka rejestracji dla pacjentów VIP.
* Obsługa w rejestracji odbywa się tak, aby pacjenci VIP **nie czekali w kolejce zwykłej** (VIP obsługiwani są z kolejki VIP).
* Na etapie triażu oraz dalszego leczenia **nie obowiązują przywileje VIP** – decyduje wyłącznie priorytet medyczny (kolory).

---

## Przebieg wizyty na SOR

### A. Rejestracja

* Pacjent podaje swoje dane oraz opisuje objawy.

### B. Ocena stanu zdrowia (Triaż)

* Lekarz POZ weryfikuje stan pacjenta i przypisuje mu kolor zgodny z pilnością udzielenia pomocy (na tej podstawie określa się, kto otrzyma pomoc w pierwszej kolejności):

  * **czerwony** – bezpośrednie zagrożenie życia, wymaga natychmiastowej pomocy (ok. 10% pacjentów),
  * **żółty** – przypadek pilny, wymagający szybkiej interwencji (ok. 35% pacjentów),
  * **zielony** – stan stabilny, pacjent może oczekiwać po przypadkach czerwonych i żółtych (ok. 50% pacjentów).
* Około **5% pacjentów** jest odsyłanych do domu bezpośrednio z triażu.
* Po przypisaniu koloru lekarz POZ kieruje pacjenta do lekarza specjalisty:

  * lekarz POZ (triaż)
  * kardiologa,
  * neurologa,
  * okulisty,
  * laryngologa,
  * chirurga,
  * pediatry.

### C. Wstępna diagnostyka i leczenie

* Lekarz specjalista wykonuje niezbędne badania (wywiad, badanie fizykalne, EKG, pomiar ciśnienia itp.) w celu stabilizacji stanu pacjenta.

### D. Decyzja o dalszym postępowaniu

Po zakończeniu diagnostyki pacjent może zostać:

* wypisany do domu (ok. 85% pacjentów),
* skierowany na dalsze leczenie do odpowiedniego oddziału szpitalnego (ok. 14,5% pacjentów),
* skierowany do innej, specjalistycznej placówki (ok. 0,5% pacjentów).

---

## Reprezentacja dzieci (proces + 2 wątki)

* Pacjent jest realizowany jako **proces**.
* Jeżeli pacjent ma mniej niż 18 lat, w ramach jednego procesu pacjenta działają **dwa wątki**:

  * wątek **Rodzica** – komunikuje się z rejestracją i realizuje etap A (rejestracja),
  * wątek **Dziecka** – realizuje pozostałe etapy (B, C, D) po zakończeniu rejestracji.
* Wątek Dziecka rozpoczyna etap triażu dopiero po potwierdzeniu zakończenia rejestracji przez wątek Rodzica.

---

## Sygnały sterujące i rola Dyrektora

* Proces **Dyrektora** zarządza symulacją i wysyła sygnały do procesów (lekarzy/pacjentów).
* **Sygnał 1 (SIGUSR1)**: wysyłany przez Dyrektora do wybranego lekarza specjalisty. Sterowanie odbywa się klawiszami w command linie w trakcie działania programu wpisując tylko np. 1.

  * nie dotyczy lekarza POZ
  * `1` → kardiolog,
  * `2` → neurolog,
  * `3` → okulista,
  * `4` → laryngolog,
  * `5` → chirurg,
  * `6` → pediatra.
  * `7` → SIGUSR2 (wszyscy opuszczają SOR).

  Po otrzymaniu SIGUSR1 dany lekarz specjalista:

  * kończy obsługę bieżącego pacjenta,
  * przerywa pracę na SOR i udaje się na oddział,
  * wraca na SOR po losowo określonym czasie.
* **Sygnał 2 (SIGUSR2)**: wysyłany przez Dyrektora do wszystkich procesów symulacji. Po otrzymaniu SIGUSR2:

  * wszyscy pacjenci i lekarze natychmiast opuszczają SOR,
  * symulacja zostaje zakończona.

---

## Struktura symulacji i raportowanie

Należy zaimplementować procedury / procesy:

* **Dyrektor**
* **Rejestracja - 1 proces/2 wątki**
* **Lekarz **
* **Pacjent**


Chciałbym żeby dyrektor generował randomowo pacjentów. Nie jakiś inny proces.


Symulacja realizowana jest na procesach (fork/exec) i mechanizmach IPC, bez aktywnego oczekiwania (busy-wait). Po dowolnym wyłączeniu ipcs i ps mają być wyczyszczone. htop w trakcie programu ma nie pokazywać 100% na każdym wątku procesora. Generalnie unikamy IPC_NOWAIT. Raport z przebiegu symulacji należy zapisywać do pliku (plików) tekstowego na wzór:

[   0.82s] Okienko rejestracji 1 rozpoczyna pracę
[   0.83s] Lekarz neurolog rozpoczyna pracę
[   0.84s] Lekarz okulista rozpoczyna pracę
[   0.84s] Lekarz pediatra rozpoczyna pracę
[   0.85s] Lekarz POZ (triaż) rozpoczyna pracę
[   0.85s] Lekarz chirurg rozpoczyna pracę
[   0.86s] [RegCtrl] Kontroler rejestracji startuje (K=10)
[   0.86s] Lekarz kardiolog rozpoczyna pracę
[   0.87s] Lekarz laryngolog rozpoczyna pracę
[   0.87s] [Generator] Generator pacjentów startuje
[   0.88s] Pacjent 1 pojawia się przed SOR (wiek 21)
[   0.88s] Pacjent 1 wchodzi do budynku
[   0.89s] Pacjent 1 dołącza do kolejki rejestracji
[   0.90s] Pacjent 1 podchodzi do okienka rejestracji 1
[   0.97s] Pacjent 2 pojawia się przed SOR (wiek 22)
[   0.97s] Pacjent 2 wchodzi do budynku
[   0.98s] Pacjent 2 dołącza do kolejki rejestracji
[   0.99s] Pacjent 1 przekazany do triażu, czeka na lekarza POZ
[   0.99s] Pacjent 2 podchodzi do okienka rejestracji 1
[   1.00s] Pacjent 1 jest weryfikowany przez lekarza POZ
[   1.09s] Pacjent 1 uzyskuje status [czerwony] — kierowany do lekarza: laryngolog
[   1.10s] Pacjent 1 czeka na lekarza: laryngolog (kolor: czerwony)
[   1.11s] Pacjent 3 pojawia się przed SOR (wiek 23)
[   1.13s] Pacjent 3 wchodzi do budynku
[   3.47s] Pacjent 15 pojawia się przed SOR (wiek 11, z opiekunem)

Program ma być uruchamiany ./sor i ma symulować, bez dodatkowych parametrów. C

